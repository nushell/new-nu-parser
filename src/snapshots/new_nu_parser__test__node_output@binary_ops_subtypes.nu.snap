---
source: src/test.rs
expression: evaluate_example(path)
input_file: tests/binary_ops_subtypes.nu
---
==== COMPILER ====
0: Int (0 to 1) "1"
1: Equal (2 to 4)
2: Float (5 to 8) "1.0"
3: BinaryOp { lhs: NodeId(0), op: NodeId(1), rhs: NodeId(2) } (0 to 8)
4: String (9 to 12) ""a""
5: Equal (13 to 15)
6: Float (16 to 19) "1.0"
7: BinaryOp { lhs: NodeId(4), op: NodeId(5), rhs: NodeId(6) } (9 to 19)
8: Int (20 to 21) "1"
9: Plus (22 to 23)
10: Float (24 to 27) "1.0"
11: BinaryOp { lhs: NodeId(8), op: NodeId(9), rhs: NodeId(10) } (20 to 27)
12: Int (29 to 30) "1"
13: List([NodeId(12)]) (28 to 30)
14: Append (32 to 34)
15: Float (36 to 39) "1.0"
16: List([NodeId(15)]) (35 to 39)
17: BinaryOp { lhs: NodeId(13), op: NodeId(14), rhs: NodeId(16) } (28 to 39)
18: Float (42 to 45) "1.0"
19: Int (46 to 47) "1"
20: List([NodeId(18), NodeId(19)]) (41 to 47)
21: Append (49 to 51)
22: String (53 to 56) ""a""
23: List([NodeId(22)]) (52 to 56)
24: BinaryOp { lhs: NodeId(20), op: NodeId(21), rhs: NodeId(23) } (41 to 56)
25: Int (60 to 61) "1"
26: List([NodeId(25)]) (59 to 61)
27: Int (64 to 65) "2"
28: List([NodeId(27)]) (63 to 65)
29: List([NodeId(26), NodeId(28)]) (58 to 66)
30: Append (68 to 70)
31: Int (73 to 74) "3"
32: List([NodeId(31)]) (72 to 74)
33: List([NodeId(32)]) (71 to 75)
34: BinaryOp { lhs: NodeId(29), op: NodeId(30), rhs: NodeId(33) } (58 to 75)
35: Int (79 to 80) "1"
36: List([NodeId(35)]) (78 to 80)
37: Int (83 to 84) "2"
38: List([NodeId(37)]) (82 to 84)
39: List([NodeId(36), NodeId(38)]) (77 to 85)
40: Append (87 to 89)
41: Float (92 to 95) "3.0"
42: List([NodeId(41)]) (91 to 95)
43: List([NodeId(42)]) (90 to 96)
44: BinaryOp { lhs: NodeId(39), op: NodeId(40), rhs: NodeId(43) } (77 to 96)
45: Int (98 to 99) "1"
46: In (100 to 102)
47: Float (104 to 107) "1.0"
48: Int (109 to 110) "1"
49: List([NodeId(47), NodeId(48)]) (103 to 110)
50: BinaryOp { lhs: NodeId(45), op: NodeId(46), rhs: NodeId(49) } (98 to 110)
51: Float (112 to 115) "2.3"
52: Modulo (116 to 119)
53: Int (120 to 121) "1"
54: BinaryOp { lhs: NodeId(51), op: NodeId(52), rhs: NodeId(53) } (112 to 121)
55: String (124 to 125) "b"
56: Int (127 to 128) "2"
57: String (130 to 131) "c"
58: Int (133 to 134) "3"
59: Record { pairs: [(NodeId(55), NodeId(56)), (NodeId(57), NodeId(58))] } (123 to 135)
60: List([NodeId(59)]) (122 to 135)
61: Append (137 to 139)
62: String (142 to 143) "a"
63: Int (145 to 146) "3"
64: String (148 to 149) "b"
65: Float (151 to 154) "1.5"
66: String (156 to 157) "c"
67: String (159 to 164) ""foo""
68: Record { pairs: [(NodeId(62), NodeId(63)), (NodeId(64), NodeId(65)), (NodeId(66), NodeId(67))] } (141 to 165)
69: List([NodeId(68)]) (140 to 165)
70: BinaryOp { lhs: NodeId(60), op: NodeId(61), rhs: NodeId(69) } (122 to 165)
71: Block(BlockId(0)) (0 to 167)
==== SCOPE ====
0: Frame Scope, node_id: NodeId(71) (empty)
==== TYPES ====
0: int
1: forbidden
2: float
3: bool
4: string
5: error
6: float
7: bool
8: int
9: forbidden
10: float
11: float
12: int
13: list<int>
14: forbidden
15: float
16: list<float>
17: list<number>
18: float
19: int
20: list<number>
21: forbidden
22: string
23: list<string>
24: list<oneof<number, string>>
25: int
26: list<int>
27: int
28: list<int>
29: list<list<int>>
30: forbidden
31: int
32: list<int>
33: list<list<int>>
34: list<list<int>>
35: int
36: list<int>
37: int
38: list<int>
39: list<list<int>>
40: forbidden
41: float
42: list<float>
43: list<list<float>>
44: list<list<number>>
45: int
46: forbidden
47: float
48: int
49: list<number>
50: bool
51: float
52: forbidden
53: int
54: float
55: unknown
56: int
57: unknown
58: int
59: record<b: int, c: int>
60: list<record<b: int, c: int>>
61: forbidden
62: unknown
63: int
64: unknown
65: float
66: unknown
67: string
68: record<a: int, b: float, c: string>
69: list<record<a: int, b: float, c: string>>
70: list<record<a: int, b: number, c: oneof<int, string>>>
71: list<record<a: int, b: number, c: oneof<int, string>>>
==== TYPE ERRORS ====
Error (NodeId 5): type mismatch: unsupported incompatible types for equal between string and float
==== IR ====
register_count: 1
file_count: 0
0: LoadLiteral { dst: RegId(0), lit: Int(1) }
==== IR ERRORS ====
Error (NodeId 2): node Float not suported yet
