---
source: src/test.rs
expression: evaluate_example(path)
input_file: tests/def_generics.nu
---
==== COMPILER ====
0: Name (4 to 5) "f"
1: Name (6 to 7) "T"
2: Params([NodeId(1)]) (5 to 8)
3: Name (11 to 12) "x"
4: Name (14 to 15) "T"
5: Type { name: NodeId(4), args: None, optional: false } (14 to 15)
6: Param { name: NodeId(3), ty: Some(NodeId(5)) } (11 to 15)
7: Params([NodeId(6)]) (9 to 17)
8: Name (20 to 27) "nothing"
9: Type { name: NodeId(8), args: None, optional: false } (20 to 27)
10: Name (31 to 35) "list"
11: Name (36 to 37) "T"
12: Type { name: NodeId(11), args: None, optional: false } (36 to 37)
13: TypeArgs([NodeId(12)]) (35 to 38)
14: Type { name: NodeId(10), args: Some(NodeId(13)), optional: false } (31 to 35)
15: InOutType(NodeId(9), NodeId(14)) (20 to 39)
16: InOutTypes([NodeId(15)]) (20 to 39)
17: Variable (47 to 48) "z"
18: Name (50 to 51) "T"
19: Type { name: NodeId(18), args: None, optional: false } (50 to 51)
20: Variable (54 to 56) "$x"
21: Let { variable_name: NodeId(17), ty: Some(NodeId(19)), initializer: NodeId(20), is_mutable: false } (43 to 56)
22: Variable (60 to 62) "$z"
23: List([NodeId(22)]) (59 to 62)
24: Block(BlockId(0)) (39 to 65)
25: Def { name: NodeId(0), type_params: Some(NodeId(2)), params: NodeId(7), in_out_types: Some(NodeId(16)), block: NodeId(24) } (0 to 65)
26: Variable (71 to 73) "l1"
27: Name (76 to 77) "f"
28: Int (78 to 79) "1"
29: Call { parts: [NodeId(27), NodeId(28)] } (78 to 79)
30: Let { variable_name: NodeId(26), ty: None, initializer: NodeId(29), is_mutable: false } (67 to 79)
31: Variable (85 to 87) "l2"
32: Name (90 to 91) "f"
33: Int (92 to 93) "2"
34: Call { parts: [NodeId(32), NodeId(33)] } (92 to 93)
35: Let { variable_name: NodeId(31), ty: None, initializer: NodeId(34), is_mutable: false } (81 to 93)
36: Variable (98 to 100) "l3"
37: Name (102 to 106) "list"
38: Name (107 to 113) "number"
39: Type { name: NodeId(38), args: None, optional: false } (107 to 113)
40: TypeArgs([NodeId(39)]) (106 to 114)
41: Type { name: NodeId(37), args: Some(NodeId(40)), optional: false } (102 to 106)
42: Variable (117 to 120) "$l2"
43: Let { variable_name: NodeId(36), ty: Some(NodeId(41)), initializer: NodeId(42), is_mutable: false } (94 to 120)
44: Block(BlockId(1)) (0 to 121)
==== SCOPE ====
0: Frame Scope, node_id: NodeId(44)
  variables: [ l1: NodeId(26), l2: NodeId(31), l3: NodeId(36) ]
      decls: [ f: NodeId(0) ]
1: Frame Scope, node_id: NodeId(24)
  variables: [ x: NodeId(3), z: NodeId(17) ]
  type decls: [ T: NodeId(1) ]
==== TYPES ====
0: unknown
1: unknown
2: unknown
3: unknown
4: unknown
5: T
6: T
7: forbidden
8: unknown
9: unknown
10: unknown
11: unknown
12: T
13: forbidden
14: unknown
15: unknown
16: unknown
17: T
18: unknown
19: T
20: T
21: ()
22: T
23: list<T>
24: list<T>
25: ()
26: list<top>
27: unknown
28: int
29: list<top>
30: ()
31: list<number>
32: unknown
33: int
34: list<number>
35: ()
36: list<number>
37: unknown
38: unknown
39: number
40: forbidden
41: list<number>
42: list<number>
43: ()
44: ()
==== IR ====
register_count: 0
file_count: 0
==== IR ERRORS ====
Error (NodeId 25): node Def { name: NodeId(0), type_params: Some(NodeId(2)), params: NodeId(7), in_out_types: Some(NodeId(16)), block: NodeId(24) } not suported yet
