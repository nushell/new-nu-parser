---
source: src/test.rs
expression: evaluate_example(path)
input_file: tests/binary_ops_exact.nu
---
==== COMPILER ====
0: Int (0 to 1) "1"
1: Equal (2 to 4)
2: Int (5 to 6) "1"
3: BinaryOp { lhs: NodeId(0), op: NodeId(1), rhs: NodeId(2) } (0 to 6)
4: True (8 to 12)
5: List([NodeId(4)]) (7 to 12)
6: Append (14 to 16)
7: False (18 to 23)
8: List([NodeId(7)]) (17 to 23)
9: BinaryOp { lhs: NodeId(5), op: NodeId(6), rhs: NodeId(8) } (7 to 23)
10: Int (25 to 26) "1"
11: Plus (27 to 28)
12: Int (29 to 30) "1"
13: BinaryOp { lhs: NodeId(10), op: NodeId(11), rhs: NodeId(12) } (25 to 30)
14: Float (31 to 34) "1.0"
15: Plus (35 to 36)
16: Float (37 to 40) "1.0"
17: BinaryOp { lhs: NodeId(14), op: NodeId(15), rhs: NodeId(16) } (31 to 40)
18: True (41 to 45)
19: And (46 to 49)
20: False (50 to 55)
21: BinaryOp { lhs: NodeId(18), op: NodeId(19), rhs: NodeId(20) } (41 to 55)
22: String (56 to 61) ""foo""
23: RegexMatch (62 to 64)
24: String (65 to 70) "".*o""
25: BinaryOp { lhs: NodeId(22), op: NodeId(23), rhs: NodeId(24) } (56 to 70)
26: Int (71 to 72) "1"
27: In (73 to 75)
28: Int (77 to 78) "1"
29: Int (80 to 81) "2"
30: List([NodeId(28), NodeId(29)]) (76 to 81)
31: BinaryOp { lhs: NodeId(26), op: NodeId(27), rhs: NodeId(30) } (71 to 81)
32: Block(BlockId(0)) (0 to 83)
==== SCOPE ====
0: Frame Scope, node_id: NodeId(32) (empty)
==== TYPES ====
0: int
1: forbidden
2: int
3: bool
4: bool
5: list<bool>
6: forbidden
7: bool
8: list<bool>
9: list<bool>
10: int
11: forbidden
12: int
13: int
14: float
15: forbidden
16: float
17: float
18: bool
19: forbidden
20: bool
21: bool
22: string
23: forbidden
24: string
25: bool
26: int
27: forbidden
28: int
29: int
30: list<int>
31: bool
32: bool
==== IR ====
register_count: 2
file_count: 0
0: LoadLiteral { dst: RegId(0), lit: Int(1) }
1: LoadLiteral { dst: RegId(1), lit: Int(1) }
==== IR ERRORS ====
Error (NodeId 1): unrecognized operator Equal
